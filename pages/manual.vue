<template>
  <div>
    <div id="content" class="scrollable-content">
      <hr>
      <h1>Handleiding</h1>
      <h2>Minecraft:</h2>
      <p>Creëer een modpack met de benodigde mods: MineColonies, CC: Tweaked, Advanced Peripherals en Applied
        Energistics.</p>
      <p>Start de modpack op en maak een wereld aan.</p>
      <p>Start in deze wereld een Colony</p>
      <p>Maak een warehouse (Figuur 13) en een courier (Figuur 14).</p>
      <div class="figure-text">
        <div class="figure">
          <img src="/assets/img/warehouse.png" alt="Warehouse">
          <div class="figure-caption">Figuur 13: Warehouse [11]</div>
        </div>
        <div class="figure">
          <img src="/assets/img/courier.png" alt="Courier">
          <div class="figure-caption">Figuur 14: Courier [11]</div>
        </div>
      </div>
      <hr>
      <p>Maak 2 ME systems aan, 1 voor de items van de colony, 1 voor de items van de speler.</p>
      <div class="figure-text">
        <p>Verbind de warehouse met Applied Energistics met een ME Storage bus (Figuur 15) met de colony ME system.</p>
        <div class="figure">
          <img src="/assets/img/warehouseStorage.png" alt="ME Storage bus">
          <div class="figure-caption">Figuur 15: Warehouse met storage bus</div>
        </div>
      </div>
      <div class="figure-text">
        <p>Verbind een Advanced computer (Figuur 20) met 2 Me Bridges (Figuur 19), 2 ME Interfaces (Figuur 18), 1 Colony
          integrator (Figuur 17) en 1 monitor (Figuur 16) zoals in onderstaande foto’s (Figuur 21 en Figuur 22). Houd
          hierbij goed bij welke ME bridge en ME interface met welk ME-system verbonden is.</p>
        <div class="figure">
          <img src="/assets/img/advancedComputer.png" alt="Advanced computer">
          <div class="figure-caption">Figuur 20: Advanced computer [3]</div>
        </div>
        <div class="figure">
          <img src="/assets/img/MEbridge.png" alt="ME-Bridge">
          <div class="figure-caption">Figuur 19: ME-Bridge [13]</div>
        </div>
        <div class="figure">
          <img src="/assets/img/MEinterface.png" alt="ME interface">
          <div class="figure-caption">Figuur 18: ME interface [14]</div>
        </div>
        <div class="figure">
          <img src="/assets/img/colonyIntegrator.png" alt="Colony integrator">
          <div class="figure-caption">Figuur 17: Colony integrator [13]</div>
        </div>
        <div class="figure">
          <img src="/assets/img/advancedMonitor.png" alt="Advanced monitor">
          <div class="figure-caption">Figuur 16: Advanced monitor [3]</div>
        </div>
      </div>
      <div class="figure-text">
        <p>Open hierna de Advanced computer en voer het volgende commando uit: <code>Edit lua.lua</code></p>
        <p>Druk hierna op control en daarna op enter als save geselecteerd is.</p>
      </div>
      <hr>
      <h3>Programma:</h3>
      <p>Surf naar <a href="https://j-plot.lucavandenweghe.ikdoeict.be">https://j-plot.lucavandenweghe.ikdoeict.be</a>
      </p>
      <div class="figure-text">
        <p>Klik op de Download Now knop (Figuur 23)</p>
        <div class="figure">
          <img src="/assets/img/websiteHomepage.png" alt="Website home page">
          <div class="figure-caption">Figuur 23: Website home page</div>
        </div>
      </div>
      <p>Klik op de Download knop. Dit downloadt een zipfile.</p>
      <p>Unzip de zipfile.</p>
      <div class="figure-text">
        <p>Run de <code>MinecoloniesInstaller.msi</code> file (Figuur 24).</p>
        <div class="figure">
          <img src="/assets/img/unzippedFolder.png" alt="Unzipped folder">
          <div class="figure-caption">Figuur 24: Unzipped folder</div>
        </div>
      </div>
      <p>Run het programma</p>
      <div class="figure-text">
        <p>Als dit de eerste keer is dat u het programma runt dan zal volgend venster opengaan (Figuur 25).</p>
        <div class="figure">
          <img src="/assets/img/opengaan.png" alt="Instance selectie">
          <div class="figure-caption">Figuur 25: Instance selectie</div>
        </div>
      </div>
      <p>Selecteer hierin het pad naar uw modpack instance.</p>
      <p>Hierna heeft u een aantal opties: Login, Register (Figuur 26) en Install new colony (Figuur 26).</p>
      <div class="figure-text">
        <div class="figure">
          <img src="/assets/img/instanceSelectie.png" alt="Applicatie start">
          <div class="figure-caption">Figuur 26: Applicatie start</div>
        </div>
      </div>
      <p>Login: Met deze knop kan u inloggen met hetzelfde account als op de website. Als u geen account hebt kunt u een
        aanmaken via de registerknop.</p>
      <p>Register: Deze knop stuurt u door naar de website waar u een account kunt aanmaken (Figuur 27).</p>
      <div class="figure-text">
        <div class="figure">
          <img src="/assets/img/websiteRegister.png" alt="Website register">
          <div class="figure-caption">Figuur 27: Website register</div>
        </div>
      </div>
      <p>Install new colony: Op dit venster kan u de wereld selecteren waarin u een colony wilt installeren. Als er in
        deze wereld een correcte configuratie bestaat dan zal deze in de lijst staan. Selecteer de computer waarin u de
        juiste bestanden wilt installeren, en klik de Install needed files knop ().</p>
      <div class="figure-text">
        <div class="figure">
          <img src="/assets/img/installColony.png" alt="Install new colony window">
          <div class="figure-caption">Figuur 28: Install new colony window</div>
        </div>
      </div>
      <p>Hierna kunt u op de back knop drukken.</p>
      <p>Als u dit alles gedaan hebt kunt u op de Start knop drukken om de synchronisatie te starten.</p>
      <div class="figure-text">
        <p>Nu runt u op de computer in Minecraft volgend commando: <code>main</code></p>
        <p>Volg de stappen op de terminal.</p>
        <p>Nu kunt u alles op de website zien als u op de website inlogt (Figuur 29).</p>
        <div class="figure">
          <img src="/assets/img/dashboard.png" alt="Dashboard">
          <div class="figure-caption">Figuur 29: Dashboard</div>
        </div>
      </div>
    </div>
    <!-- HUD Overlay -->
    <div id="hud" v-show="show3D">
      <p>Use Arrow Keys to Move</p>
      <p>Press Space to Pick Up/Place Block</p>
      <button @click="exit3DView">Exit 3D View</button>
    </div>
    <canvas ref="canvas" v-show="show3D"></canvas>
  </div>
</template>

<script lang="ts">
import {defineComponent, onMounted, ref, watch} from 'vue';
import * as THREE from 'three';
import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls.js';
import html2canvas from 'html2canvas';

export default defineComponent({
  setup() {
    const canvas = ref<HTMLCanvasElement | null>(null);
    const show3D = ref(true);
    let texture: THREE.CanvasTexture | undefined;
    let renderer: THREE.WebGLRenderer | undefined;
    let scene: THREE.Scene | undefined;
    let camera: THREE.PerspectiveCamera | undefined;
    let controls: OrbitControls | undefined;

    const initThreeJS = () => {
      // Set up the scene, camera, and renderer
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({canvas: canvas.value!, preserveDrawingBuffer: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add OrbitControls to control the camera
      controls = new OrbitControls(camera, renderer.domElement);

      // Create a basic Steve with two cubes (simplified)
      const bodyGeometry = new THREE.BoxGeometry(2, 2, 1);
      const headGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
      const bodyMaterial = new THREE.MeshBasicMaterial({color: 0x87CEEB});
      const headMaterial = new THREE.MeshBasicMaterial({color: 0xF5CBA7});
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      const head = new THREE.Mesh(headGeometry, headMaterial);

      body.position.y = 1;
      head.position.y = 2.8;

      const steve = new THREE.Group();
      steve.add(body);
      steve.add(head);
      scene.add(steve);

      // Create cubes that Steve will move (grass blocks)
      const cubeGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
      const cubeMaterial = new THREE.MeshBasicMaterial({color: 0x219353});
      const edgeMaterial = new THREE.LineBasicMaterial({color: 0x4e576a}); // Black color for edges
      const cubes = [];

      for (let i = 0; i < 5000; i++) {
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(Math.random() * 4000 - 400, 1.1, Math.random() * 4000 - 400);  // Ensure cubes are slightly above the ground

        // Create edges for the cube
        const edges = new THREE.EdgesGeometry(cubeGeometry);
        const edgeLines = new THREE.LineSegments(edges, edgeMaterial);

        // Add the cube and its edges to the scene
        cube.add(edgeLines);
        scene.add(cube);

        cubes.push(cube);
      }

      // Set the camera to a top-down perspective
      camera.position.set(0, 20, 0);  // Camera position directly above
      camera.rotation.x = -Math.PI / 2;  // Rotate camera to look down

      // Define the planes and texture globally to update the texture later
      let plane: THREE.Mesh | undefined, backgroundPlane: THREE.Mesh | undefined;

      // Create a plane with the website as a texture
      if (!texture) {
        const contentElement = document.getElementById('content');
        if (contentElement) {
          const contentHeight = contentElement.scrollHeight;
          const contentWidth = contentElement.scrollWidth;
          contentElement.style.height = `${contentHeight}px`; // Temporarily set the height to capture full content

          html2canvas(contentElement, { height: contentHeight }).then(canvas => {
            texture = new THREE.CanvasTexture(canvas);

            const planeGeometry = new THREE.PlaneGeometry(canvas.width / 10, canvas.height / 10);  // Scale the plane to be larger
            const planeMaterial = new THREE.MeshBasicMaterial({ map: texture });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            scene.add(plane);

            // Create an extended floor with a uniform color matching the website background
            const backgroundPlaneGeometry = new THREE.PlaneGeometry(400, 900);  // Larger plane for the extended floor
            const backgroundPlaneMaterial = new THREE.MeshBasicMaterial({ color: 0x6c6c6c });  // Matching background color
            backgroundPlane = new THREE.Mesh(backgroundPlaneGeometry, backgroundPlaneMaterial);
            backgroundPlane.rotation.x = -Math.PI / 2;
            backgroundPlane.position.y = -0.01;  // Slightly below the main plane to avoid z-fighting
            scene.add(backgroundPlane);

            // Position Steve at the top-left corner of the textured plane
            steve.position.set(-planeGeometry.parameters.width / 2 + 1, 0, -planeGeometry.parameters.height / 2 + 1);

          }).catch(error => {
            console.error('Error capturing the content element:', error);
          }).finally(() => {
            contentElement.style.height = ''; // Reset the height
          });
        }
      } else {
        const planeGeometry = new THREE.PlaneGeometry(texture.image.width / 10, texture.image.height / 10);  // Scale the plane to be larger
        const planeMaterial = new THREE.MeshBasicMaterial({map: texture});
        plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = 0;
        scene.add(plane);
        console.log('Reused texture plane added to scene:', plane);

        // Create an extended floor with a uniform color matching the website background
        const backgroundPlaneGeometry = new THREE.PlaneGeometry(200, 200);  // Larger plane for the extended floor
        const backgroundPlaneMaterial = new THREE.MeshBasicMaterial({color: 0x6c6c6c});  // Matching background color
        backgroundPlane = new THREE.Mesh(backgroundPlaneGeometry, backgroundPlaneMaterial);
        backgroundPlane.rotation.x = -Math.PI / 2;
        backgroundPlane.position.y = -0.01;  // Slightly below the main plane to avoid z-fighting
        scene.add(backgroundPlane);
        console.log('Background plane added to scene:', backgroundPlane);
      }

      // Animation variables
      let steveSpeed = 0.3;
      let carryingCube: THREE.Mesh | null = null;
      let keys: { [key: string]: boolean } = {};
      const planeWidth = 2000;
      const planeHeight = 2000;

      // Event listeners for keyboard inputs
      document.addEventListener('keydown', (event) => {
        keys[event.code] = true;

        if (event.code === 'Space') {
          grabOrPlaceCube();
        }
      });

      document.addEventListener('keyup', (event) => {
        keys[event.code] = false;
      });

      // Function to move Steve based on keyboard input and prevent him from walking off the plane
      function moveSteve() {
        let moveX = 0;
        let moveZ = 0;

        if (keys['ArrowUp']) {
          moveZ = -steveSpeed;
          steve.rotation.y = 0;
        }
        if (keys['ArrowDown']) {
          moveZ = steveSpeed;
          steve.rotation.y = Math.PI;
        }
        if (keys['ArrowLeft']) {
          moveX = -steveSpeed;
          steve.rotation.y = Math.PI / 2;
        }
        if (keys['ArrowRight']) {
          moveX = steveSpeed;
          steve.rotation.y = -Math.PI / 2;
        }

        const newPositionX = steve.position.x + moveX;
        const newPositionZ = steve.position.z + moveZ;

        // Update boundary checks based on the plane size
        if (newPositionX >= -planeWidth / 2 && newPositionX <= planeWidth / 2 &&
            newPositionZ >= -planeHeight / 2 && newPositionZ <= planeHeight / 2) {
          steve.position.x = newPositionX;
          steve.position.z = newPositionZ;
        }

        detectHoverAndClick();  // Check for hover and click effect
      }

      // Function to grab or place a cube
      function grabOrPlaceCube() {
        if (carryingCube) {
          // Place the carried cube in front of Steve
          const placementX = steve.position.x - Math.sin(steve.rotation.y) * 1.5;
          const placementZ = steve.position.z - Math.cos(steve.rotation.y) * 1.5;
          if (placementX >= -planeWidth / 2 && placementX <= planeWidth / 2 &&
              placementZ >= -planeHeight / 2 && placementZ <= planeHeight / 2) {
            carryingCube.position.set(placementX, 0.5, placementZ);
            scene.add(carryingCube);  // Detach the cube from Steve and place it in the scene
            carryingCube = null;

            // Convert 3D position to screen coordinates
            const screenPosition = worldToScreen(placementX, 0.5, placementZ);
            simulateMouseClick(screenPosition.x, screenPosition.y);
          }
        } else {
          // Pick up a cube if in range
          for (let cube of cubes) {
            if (steve.position.distanceTo(cube.position) < 2.2) {
              carryingCube = cube;
              steve.add(carryingCube);  // Attach the cube to Steve
              carryingCube.position.set(0, 1.9, -1);  // Position the cube relative to Steve
              break;
            }
          }
        }
      }

      // Function to continuously update the position of the carried cube
      function updateCarriedCubePosition() {
        if (carryingCube) {
          // Use local position to ensure the cube stays in front of Steve
          carryingCube.position.set(0, 1.9, -1);
        }
      }

      // Function to simulate a mouse click at a given position
      function simulateMouseClick(x: number, y: number) {
        const element = document.elementFromPoint(x, y);
        if (element) {
          const event = new MouseEvent('click', {
            clientX: x,
            clientY: y,
            bubbles: true,
            cancelable: true,
            view: window
          });
          element.dispatchEvent(event);
        }
      }

      // Function to detect hover over buttons and click them automatically
      function detectHoverAndClick() {
        const screenPosition = worldToScreen(steve.position.x, steve.position.y, steve.position.z);

        const element = document.elementFromPoint(screenPosition.x, screenPosition.y);
        if (element && element.tagName === 'BUTTON') {
          simulateMouseClick(screenPosition.x, screenPosition.y);
        }
      }

      // Function to convert 3D world position to 2D screen coordinates
      function worldToScreen(x: number, y: number, z: number) {
        const vector = new THREE.Vector3(x, y, z);
        vector.project(camera);
        const halfWidth = window.innerWidth / 2;
        const halfHeight = window.innerHeight / 2;
        return {
          x: (vector.x * halfWidth) + halfWidth,
          y: -(vector.y * halfHeight) + halfHeight
        };
      }

      // Function to update the camera position to follow Steve
      function updateCamera() {
        const offset = new THREE.Vector3(0, 60, 18);  // Adjusted for a top-down angle
        const desiredPosition = steve.position.clone().add(offset);
        camera.position.lerp(desiredPosition, 0.3);  // Smoothly interpolate to the new position
        camera.lookAt(steve.position);
      }

      // Render loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        moveSteve();
        updateCarriedCubePosition();  // Ensure the carried cube stays in front of Steve
        updateCamera();  // Update the camera position to follow Steve
        renderer.render(scene, camera);
      }

      animate();
    };

    const exit3DView = () => {
      show3D.value = false;
      // Clean up the 3D scene if necessary
      const canvasElement = canvas.value!;
      const parent = canvasElement.parentNode;
      if (parent) {
        parent.removeChild(canvasElement);
      }
    };

    onMounted(() => {
      initThreeJS();
    });

    return {
      canvas,
      show3D,
      exit3DView
    };
  }
});
</script>

<style scoped>

body {
  margin: 0;
  overflow: hidden; /* Disable scrolling */
}

canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}

#content {
  font-family: 'Poppins', Courier, monospace;
  font-weight: bold;
  background-color: #262626;
  color: #ffffff;
  padding: 20px;
  max-width: 800px;
  margin: auto;
  overflow-y: auto;
  height: 90vh; /* Adjust this value based on your needs */
}

.scrollable-content { /* New class for content within #content */
  overflow-y: hidden; /* Disable scrolling within content for 3D view */
}

h1, h2, h3 {
  color: #a81be7;
}

a {
  color: #39baec;
}

button {
  background-color: #a81be7;
  color: #f0f0f0;
  border: none;
  padding: 10px;
  margin: 10px;
  cursor: pointer;
  transition: background-color 0.3s;
  border-radius: 5px;
}

button:hover {
  background-color: #76169f;
}

img {
  max-width: 100%;
  height: auto;
}

.figure-text {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
}

.figure {
  flex: 1;
  min-width: 200px;
  margin: 10px;
  text-align: center;
}

.figure-caption {
  text-align: center;
  margin-top: 5px;
}

/* HUD styles */
#hud {
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.5);
  color: #f0f0f0;
  padding: 10px;
  border-radius: 5px;
  font-family: 'Courier New', Courier, monospace;
  z-index: 1000; /* Ensure it's on top of the canvas */
}

/* Custom scrollbar styles */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: transparent; /* Make the background transparent */
}

::-webkit-scrollbar-thumb {
  background-color: grey; /* Set the color of the scrollbar thumb */
  border-radius: 10px; /* Make the scrollbar thumb rounded */
}
</style>
